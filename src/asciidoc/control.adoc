== Control Flow 

[, Wikipedia]
""
In computer science, control flow (or alternatively, flow of control) refers to the order in which
the individual statements, instructions or function calls of an imperative or a declarative program
are executed or evaluated
""

Control flow is one of the most important topics in a programming language. Most languages
have their own out-of-the-box control structures, and some others can create new ones on-the-fly. 
Although Groovy can't create new control structures in the classical sense, it can create control 
structures based on functions and meta-programming.

Following up there're some control flow structures I've been collecting while sneaking 
in some other programming languages. 

Let's go through them.

=== Let

Initializes a group of variables, makes them available within the scope
of the closure passed as argument.

[source,groovy]
----
    let(Map,Closure)
----

Let's see some examples.

[source,groovy]
.Simple values
----
include::{testdir}/fnz/control/LetSpecification.groovy[tags=simpleLet]
----

Here values provided by the map are accessible within the scope of the closure block.
What if I wanted to create values depending on previous values ? Let's
see the following example:

[source,groovy]
.Dependant expressions
----
include::{testdir}/fnz/control/LetSpecification.groovy[tags=computedValues]
----

In this example value of *'z'* depends on the values given to *'x'* and *'y'*. Every

[source,groovy]
.Nested expressions
----
include::{testdir}/fnz/control/LetSpecification.groovy[tags=nestedLet]
----

Previous link:https://code.google.com/p/spock[Spock] specification shows how let expressions could be nested.

=== Unless

The rationale behind *Unless* is that sometimes is just a pain to create *negative*
conditional expressions. 

[source,groovy]
----
    unless(Boolean,Closure)
----

[source,groovy]
.Unless structure
----
include::{testdir}/fnz/control/UnlessSpecification.groovy[tags=simpleUnless]
----

This expression will allow the code block to be executed unless the condition
evaluates to true.

=== Where

I would say *Where* control belongs to the family of *switch statements* or *multiway branches*.
I first read about the *Where* clause while I was reading Haskell.

This version of Haskell's Where expressions should follow these rules:

[source,groovy]
----
    check(Map) { // <1>
        when { /evaluates to boolean/ } then { /returns a value/ } // <2>
        otherwise { /returns a value/ } // <3>
        where { /some constants/ } // <4>
    }
----

<1> A where clause it's initialized by a map of values
<2> There must be at least one when-then block 
<3> Could be one or none otherwise block 
<4> There must be at least one where block

There are different ways of using this control depending on the use
of when-then expressions

[source,groovy]
.Simple Where
----
include::{testdir}/fnz/control/WhereSpecification.groovy[tags=simpleWhere]
----

This is a simple example about how to use the where expression. The when-then clauses
use closures to evaluate their content. But thanks to Groovy's objects method isCase()
we can create switch-like statements

[source,groovy]
.Switch-case Where (Class)
----
include::{testdir}/fnz/control/WhereSpecification.groovy[tags=whereSwitchLike1]
----

Instead of passing a map you can evaluate a single value against some conditions. Those
conditions are the same you would be using in a switch-case block in Groovy.

[source,groovy]
.Switch-case Where (Collections)
----
include::{testdir}/fnz/control/WhereSpecification.groovy[tags=whereSwitchLike2]
----

[source,groovy]
.Switch-case Where (Number)
----
include::{testdir}/fnz/control/WhereSpecification.groovy[tags=whereSwitchLike3]
----

